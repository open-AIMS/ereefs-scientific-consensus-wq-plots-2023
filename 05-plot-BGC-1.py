# Copyright Eric Lawrey, Australian Institute of Marine Science
# This script generates map plots of various variables from the BGC model annual 
# and seasonal aggregations generated by 03-calculate-all-time-aggregate.py and
# 04-calculate-seasonal-aggregates.py. This outputs its figure as PNG files into
# exports.
# These have one variable, with one temporal aggregation per plot. The eReefs data
# is clipped to the GBR region.
import xarray as xr
import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import os
from shapely.geometry import Point
import matplotlib.patheffects as pe
import rioxarray
from matplotlib_scalebar.scalebar import ScaleBar
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from matplotlib.font_manager import FontProperties

basemap_path = os.path.join("src-data","GBR_AIMS_eReefs-basemap")

# These files are created by the previous scripts 01-.. - 04-..
nc_all_data_file = 'GBR4_H2p0_B3p1_Cq3b_Dhnd_WQ_all_3.0m_Jan2011-Dec2018'
nc_dry_data_file = 'GBR4_H2p0_B3p1_Cq3b_Dhnd_WQ_dry_3.0m_May2011-Oct2018'
nc_wet_data_file = 'GBR4_H2p0_B3p1_Cq3b_Dhnd_WQ_wet_3.0m_Nov2012-Apr2019'

# Define map extent
extent = [142, 154.2, -26.7, -10.0]
output_path = os.path.join("export","single-plots")


def plot_gbr_ereefs(plot_info):
    nc_data_file = plot_info['nc_data_file']
    nc_var = plot_info['nc_var']
    nc_var_title = plot_info['nc_var_title']
    depth = plot_info['depth']
    time_range = plot_info['time_range']
    vmin = plot_info['vmin']
    vmax = plot_info['vmax']
    legend_ticks = plot_info['legend_ticks']
    units = plot_info['units']
    extent = plot_info['extent']
    output_path = plot_info['output_path']
    scale_type = plot_info['scale_type']
    
    # Load NetCDF data
    nc_data = xr.open_dataset(os.path.join('derived','eReefs-BGC',f'{nc_data_file}.nc'))

    clip_regions = gpd.read_file(os.path.join(basemap_path, 'GBR_AIMS_eReefs-basemap_Clip-regions.shp'))
    gbr_polygon = clip_regions[clip_regions['Region'] == 'GBR'].geometry.iloc[0]

    # Ensure the NetCDF data has spatial attributes (e.g., a CRS)
    nc_data.rio.set_spatial_dims(x_dim="longitude", y_dim="latitude", inplace=True)
    nc_data.rio.write_crs("epsg:4326", inplace=True)  # Assuming data is in WGS84

    # Clip the data
    clipped_data = nc_data.rio.clip([gbr_polygon], crs=clip_regions.crs)


    # Load shapefiles and CSV data
    land_and_basins = gpd.read_file(os.path.join(basemap_path,'GBR_AIMS_eReefs-basemap_Land-and-Basins.shp'))
    rivers = gpd.read_file(os.path.join(basemap_path,'GBR_AIMS_eReefs-basemap_GA-topo5m-drainage.shp'))
    reefs = gpd.read_file(os.path.join(basemap_path,'GBR_AIMS_eReefs-basemap_Reefs.shp'))
    cities = gpd.read_file(os.path.join(basemap_path,'GBR_AIMS_eReefs-basemap_Cities_2023.csv'))
    # ne_countries = gpd.read_file(os.path.join(basemap_path,'GBR_AIMS_eReefs-basemap_NE-countries-10m.shp'))


    water_bodies = gpd.read_file(os.path.join('src-data','GBR_NRM-Waters','Polys.shp'))



    # Define colormap for DIN
    colors = ['#380060', '#40009a', '#2c30ee', '#3a6ef1', '#2fb0fb', '#3ed6d6', '#75eedc', '#b1ffdb',
              '#deffda', '#ffff75', '#ffef71', '#ffc23d', '#ff8700', '#ff4400', '#b00026', '#5c0035']
    cmap_var = plt.cm.colors.ListedColormap(colors)
    #norm_var = plt.cm.colors.LogNorm(vmin=vmin, vmax=vmax)
    
    if scale_type == "log":
        norm_var = plt.cm.colors.LogNorm(vmin=vmin, vmax=vmax)
    else:  # If not log, use linear scale
        norm_var = plt.cm.colors.Normalize(vmin=vmin, vmax=vmax)

    # Plotting
    fig, ax = plt.subplots(figsize=(5, 8))

    ax.set_facecolor("#e0f7ff")

    nc_var_plot = clipped_data[nc_var].plot(ax=ax, cmap=cmap_var, norm=norm_var, add_colorbar=False, extend='both')

    # ============= Legend =============
    # Create an inset axes for the colorbar
    width_percent = "5%"  # This ensures the colorbar will be 80% of the main ax width
    height_percent = "30%"  # Height of the colorbar, modify as needed
    pad_fraction = 0.8  # Padding between main ax and colorbar, modify as needed

    cax = inset_axes(ax, 
                     width=width_percent, 
                     height=height_percent, 
                     loc='lower left', 
                     borderpad=pad_fraction,
                     axes_kwargs={"facecolor" : "w"})  # this makes the background of the colorbar white

    # Add the colorbar to the inset axes
    cbar = plt.colorbar(nc_var_plot, cax=cax, orientation='vertical')
    label_text = r'{} {}'.format(nc_var, units)
    cbar.set_label(label_text, labelpad=4)

    # Define the tick levels
    tick_levels = legend_ticks
    cbar.set_ticks(tick_levels)
    tick_labels = [str(level) for level in tick_levels]
    cbar.set_ticklabels(tick_labels)


    # ========== Base map ============
    basin_colors = {
        'country': '#F7F7EB',
        'island': '#F7F7EB',
        'state': '#F7F7EB',
        'dbasin_0': '#f0f0eb',
        'dbasin_1': '#e6e6e1',
        'dbasin_2': '#f7f7f2'
    }
    land_and_basins_filtered = land_and_basins[land_and_basins['SOVEREIGNT'] == 'Australia']
    land_and_basins_filtered.plot(ax=ax, 
                         color=land_and_basins_filtered['BASIN_ALT'].map(basin_colors), 
                         edgecolor='#B4B5B1', 
                         linewidth=0.2)

    rivers.plot(ax=ax, color='#3B5998', linewidth=0.5, alpha = 0.3)

    # Convert latitude and longitude to geometry for cities
    cities['geometry'] = cities.apply(lambda row: Point(row['longitude'], row['latitude']), axis=1)
    cities_gdf = gpd.GeoDataFrame(cities)
    cities_gdf_filtered = cities_gdf[cities_gdf['scs_scale'] == '1']

    # Further filter out cities with names 'Bowen' and 'Maryborough'
    cities_gdf_filtered = cities_gdf_filtered[~cities_gdf_filtered['name'].isin(['Bowen', 'Maryborough'])]


    # Cities with 'scs_scale' of 1
    cities_gdf_filtered.plot(ax=ax, color='black', markersize=10)
    for x, y, label in zip(cities_gdf_filtered.geometry.x, cities_gdf_filtered.geometry.y, cities_gdf_filtered['name']):
        ax.text(x, y, label + ' ', verticalalignment='center', horizontalalignment='right', fontsize=8, 
                path_effects=[pe.withStroke(linewidth=3, foreground='white')])

    # Just keep the reefs in the GBR. We don't need Coral Sea reefs as we are clipping to the GBR.
    reefs_filtered = reefs[reefs['Region'] == 'GBR']
    reefs_filtered.plot(ax=ax, color='black', alpha=0.4)

    # ============== Water bodies ==================
    water_bodies.plot(ax=ax, 
                facecolor='none',
                edgecolor='#000000', 
                linewidth=0.3)

    # ============= Overview map ==================
    # Lets not worry about the overview map for now.
    if False:
        ax_inset = fig.add_axes([0.05, 0.05, 0.25, 0.25])
        ne_countries.boundary.plot(ax=ax_inset, color='none', edgecolor='k', linewidth=0.2)
        ne_countries.plot(ax=ax_inset, color='#F5F5F5', edgecolor='none')
        rect = plt.Rectangle((extent[0], extent[2]), extent[1]-extent[0], extent[3]-extent[2], fill=False, color='red', linewidth=1)
        ax_inset.add_patch(rect)
        ax_inset.set_title('Overview Map')
        ax_inset.set_xticks([])
        ax_inset.set_yticks([])
        ax_inset.spines['top'].set_visible(False)
        ax_inset.spines['right'].set_visible(False)
        ax_inset.spines['bottom'].set_visible(False)
        ax_inset.spines['left'].set_visible(False)

    # ============ Extents and figure tick marks ==============
    ax.set_xlim(extent[0], extent[1])
    ax.set_ylim(extent[2], extent[3])

    # Remove ticks, ticklabels, and axis labels
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_xlabel('')
    ax.set_ylabel('')


    # =============== Scale bar ==================
    # Compute the length of the scale bar at -26 degrees latitude to match the bottom of the map.
    # Since we are using EPSG:4326 with units of degrees, the length of the scale bar varies across
    # the latitude of the map. We therefore use just a scale bar with length corresponding to the 
    # latitute of where it is placed on the map.
    scale_bar_placement_frac = 0.08  # Fraction of the scale bar height of the plot y axis
    lat = (extent[3] - extent[2])*scale_bar_placement_frac+extent[3]  # degrees

    # Assume the Earth is a sphere.
    # https://stackoverflow.com/questions/639695/how-to-convert-latitude-or-longitude-to-meters
    length_km_per_degree = 40075 / 360 * np.cos(np.radians(lat))

    # Define font properties for the scale bar
    #font_props = FontProperties(size=10)

    scalebar = ScaleBar(dx = length_km_per_degree, 
        location="lower right", 
        scale_loc='bottom', 
        units='km', 
        length_fraction=0.2, # 20% of the plot width
        pad=0.3,
        box_alpha=0,  # No background fill
        font_properties={'size': 8})  # Use the defined font properties
    ax.add_artist(scalebar)

    # ================== Title ==================
    ax.set_title(f"{nc_var_title}", fontsize=12, fontweight='bold', color='black')


    # ================== Metadata ===================
    divider = make_axes_locatable(ax)
    ax_sub = divider.append_axes("bottom", size="3%", pad=0.05)  # adjust size and pad as needed

    ax_sub.axis('off')
    ax_sub.text(0.05, 0.5, f"Data: GBR4_H2p0_B3p1_Cq3b_Dhnd, Variable: {nc_var}, Aggregation: mean\nDepth: {str(-depth)} m, Time range: {time_range}", ha='left', va='center', fontsize=8)

    # Determine the aspect ratio
    aspect_ratio = fig.get_figwidth() / fig.get_figheight()

    # Compute the width in inches based on desired height in pixels and dpi
    desired_height_in_pixels = 3000
    dpi = desired_height_in_pixels / fig.get_figheight()

    plt.subplots_adjust(left=0.0, right=1, top=1, bottom=0.0)

    # ================ Save the result ==============
    if not os.path.exists(output_path):
        os.makedirs(output_path)
        
    # Save the figure
    output_path = os.path.join(output_path, f"{nc_data_file}_{nc_var}.png")
    plt.savefig(output_path, dpi=dpi)

    # plt.show()
    # Close the figure after saving to free up memory
    plt.close()


def generate_plots(plots_info):
    for plot_info in plots_info:
        if not plot_info['skip']:
            print(f"Rendering {plot_info['nc_var_title']}...")
            plot_gbr_ereefs(plot_info)
        else:
            print(f"Skipping {plot_info['nc_var_title']}...")
        
def make_wq_plots(season, time_range, nc_file):
    '''
    Utility function to make it easier to create plots for Annual, Wet and Dry seasons 
    while reusing most of the settings. This function relies on a number of global
    variables so it is not a clean reusable function.
    '''
    plots_info = [
        {
            'nc_data_file': nc_file,
            'nc_var': 'DIN',
            'nc_var_title': f'Dissolved Inorganic Nitrogen - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 0.1,
            'vmax': 10,
            'legend_ticks': [0.1, 0.2, 0.5, 1, 2, 5, 10],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'log',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'DIP',
            'nc_var_title': f'Dissolved Inorganic Phosphorus - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 0.1,
            'vmax': 5,
            'legend_ticks': [0.1, 0.2, 0.5, 1, 2, 5],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'log',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'TN',
            'nc_var_title': f'Total Nitrogen - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 40,
            'vmax': 200,
            'legend_ticks': [40, 80, 120, 160, 200],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'linear',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'TP',
            'nc_var_title': f'Total Phosphorus - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 3,
            'vmax': 12,
            'legend_ticks': [3, 4, 5, 6, 8, 10, 12],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'linear',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'Chl_a_sum',
            'nc_var_title': f'Total Chlorophyll a - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 0.1,
            'vmax': 1.5,
            'legend_ticks': [0.1, 0.2, 0.3, 0.5, 0.7, 1, 1.2, 1.5],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'log',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'NO3',
            'nc_var_title': f'Nitrate - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 0.1,
            'vmax': 10,
            'legend_ticks': [0.1, 0.2, 0.5, 1, 2, 5, 10],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'log',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'NH4',
            'nc_var_title': f'Ammonia - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 0.05,
            'vmax': 1,
            'legend_ticks': [0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 1],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'log',
            'scale_type': 'log',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'DOR_N',
            'nc_var_title': f'Dissolved Organic Nitrogen - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 30,
            'vmax': 120,
            'legend_ticks': [30, 40, 50, 60, 70, 80, 90, 100, 110, 120],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'linear',
            'skip': False
        },
        {
            'nc_data_file': nc_file,
            'nc_var': 'DOR_P',
            'nc_var_title': f'Dissolved Organic Phosphorus - {season}',
            'depth': -3,
            'time_range': time_range,
            'vmin': 3,
            'vmax': 12,
            'legend_ticks': [3, 4, 5, 6, 8, 10, 12],
            'units':'($\mu$g/L)',
            'extent' : extent,
            'output_path': output_path,
            'scale_type': 'linear',
            'skip': False
        }
    ]
    return plots_info

generate_plots(make_wq_plots('Annual','Jan 2011 - Dec 2018', nc_all_data_file))

# The months in the wet and dry season are specified in the 04-calculate-seasonal-aggregates.py script
generate_plots(make_wq_plots('Wet Season','Nov - Apr 2012 - 2019',nc_wet_data_file))
generate_plots(make_wq_plots('Dry Season','May - Oct 2011 - 2018',nc_dry_data_file))

print("Finished plotting.")